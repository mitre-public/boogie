package org.mitre.tdp.boogie.alg.resolve;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Objects.requireNonNull;

import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

import org.mitre.caasd.commons.Pair;
import org.mitre.caasd.commons.util.Partitioners;
import org.mitre.tdp.boogie.Fix;
import org.mitre.tdp.boogie.Leg;
import org.mitre.tdp.boogie.Procedure;
import org.mitre.tdp.boogie.RequiredNavigationEquipage;
import org.mitre.tdp.boogie.Transition;
import org.mitre.tdp.boogie.TransitionType;
import org.mitre.tdp.boogie.alg.ExpandedRoute;
import org.mitre.tdp.boogie.alg.RouteExpander;
import org.mitre.tdp.boogie.alg.RouteSummary;
import org.mitre.tdp.boogie.alg.split.SectionSplit;
import org.mitre.tdp.boogie.fn.QuadFunction;
import org.mitre.tdp.boogie.util.TransitionSorter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Functional class for generating route 'summary' from the {@link ExpandedRoute} returned by the {@link RouteExpander}.
 * <br>
 * This class crawls the expanded route and its source elements and up-levels summary information related to the arrival/departure
 * airport, SID/STAR, approach, runways, and arrival/departure fixes.
 */
public final class ExpandedRouteSummarizer implements QuadFunction<List<ResolvedLeg>, String, String, String, Optional<RouteSummary>> {

  private static final Logger LOG = LoggerFactory.getLogger(ExpandedRouteSummarizer.class);

  public static final ExpandedRouteSummarizer INSTANCE = new ExpandedRouteSummarizer();

  private ExpandedRouteSummarizer() {
  }

  /**
   * Summarizes the contents of the input ExpandedRoute as a RouteSummary:
   * <br>
   * @param resolvedLegs - the list of {@link ResolvedLeg}s generated by the {@link RouteExpander}
   * @param departureRunway - the departure runway id provided to the expander during expansion (this may be null)
   * @param arrivalRunway - the arrival runway id provided to the expander during expansion (this may be null)
   */
  @Override
  public Optional<RouteSummary> apply(List<ResolvedLeg> resolvedLegs, String route, @Nullable String departureRunway, @Nullable String arrivalRunway) {
    requireNonNull(route, "The provided route must not be null.");
    checkArgument(!resolvedLegs.isEmpty(), "Input sequence of resolved legs cannot be empty");

    Optional<String> departureAirport = departureAirport(resolvedLegs.get(0));
    Optional<String> arrivalAirport = arrivalAirport(resolvedLegs.get(resolvedLegs.size() - 1));

    if (departureAirport.isPresent() || arrivalAirport.isPresent()) {

      RouteSummary.Builder builder = new RouteSummary.Builder()
          .route(route)
          .arrivalAirport(arrivalAirport.orElse(null))
          .arrivalRunway(arrivalRunway)
          .departureAirport(departureAirport.orElse(null))
          .departureRunway(departureRunway);

      StarFeatureResolver.INSTANCE.apply(resolvedLegs).ifPresent(summary -> builder
          .star(summary.procedureName())
          .starEntryFix(summary.entryExitFix())
          .arrivalFix(summary.arrivalDepartureFix())
          .requiredStarEquipage(summary.equipage())
      );

      SidFeatureResolver.INSTANCE.apply(resolvedLegs).ifPresent(summary -> builder
          .sid(summary.procedureName())
          .sidExitFix(summary.entryExitFix())
          .departureFix(summary.arrivalDepartureFix())
          .requiredSidEquipage(summary.equipage())
      );

      ApproachFeatureResolver.INSTANCE.apply(resolvedLegs).ifPresent(summary -> builder
          .approach(summary.procedureName())
          .approachEntryFix(summary.entryExitFix())
          .requiredApproachEquipage(summary.equipage())
      );

      return Optional.of(builder.build());
    } else {
      LOG.warn("Unable to reliably summarize route without Arrival/Departure airport.");
      return Optional.empty();
    }
  }

  private Optional<String> departureAirport(ResolvedLeg initialLeg) {
    return Optional.of(initialLeg).filter(leg -> leg.sourceElement() instanceof AirportElement).map(ResolvedLeg::split).map(SectionSplit::value);
  }

  private Optional<String> arrivalAirport(ResolvedLeg finalLeg) {
    return Optional.of(finalLeg).filter(leg -> leg.sourceElement() instanceof AirportElement).map(ResolvedLeg::split).map(SectionSplit::value);
  }

  /**
   * Functional class for extracting common STAR features from an {@link ExpandedRoute}.
   */
  private static final class StarFeatureResolver implements Function<List<ResolvedLeg>, Optional<ProcedureSummary>> {

    private static final StarFeatureResolver INSTANCE = new StarFeatureResolver();

    @Override
    public Optional<ProcedureSummary> apply(List<ResolvedLeg> resolvedLegs) {
      return legsFromElement(resolvedLegs, StarElement.class).stream().reduce((l1, l2) -> l2)
          .map(starLegs -> {
            Procedure star = ((StarElement) starLegs.get(0).sourceElement()).procedure();
            Map<Leg, Transition> transitionEmbedding = transitionEmbedding(star);

            Optional<String> arrivalFix = starLegs.stream().filter(leg -> TransitionType.COMMON.equals(transitionEmbedding.get(leg.leg()).transitionType()))
                .findFirst().map(ResolvedLeg::leg).flatMap(Leg::associatedFix).map(Fix::fixIdentifier);

            return new ProcedureSummary.Builder()
                .procedureName(star.procedureIdentifier())
                .entryExitFix(starLegs.get(0).leg().associatedFix().map(Fix::fixIdentifier).orElse(null))
                .arrivalDepartureFix(arrivalFix.orElse(null))
                .equipage(star.requiredNavigationEquipage())
                .build();
          });
    }

    private Map<Leg, Transition> transitionEmbedding(Procedure star) {
      return TransitionSorter.INSTANCE.sortStarTransitions(star.transitions()).stream()
          .flatMap(Collection::stream)
          .flatMap(transition -> transition.legs().stream().map(leg -> Pair.of(leg, transition)))
          .collect(elidingCollector(Pair::first, Pair::second));
    }
  }

  /**
   * Functional class for extracting common SID features from an {@link ExpandedRoute}.
   */
  private static final class SidFeatureResolver implements Function<List<ResolvedLeg>, Optional<ProcedureSummary>> {

    private static final SidFeatureResolver INSTANCE = new SidFeatureResolver();

    @Override
    public Optional<ProcedureSummary> apply(List<ResolvedLeg> resolvedLegs) {
      return legsFromElement(resolvedLegs, SidElement.class).stream().findFirst()
          .map(sidLegs -> {
            Procedure sid = ((SidElement) sidLegs.get(0).sourceElement()).procedure();
            Map<Leg, Transition> transitionEmbedding = transitionEmbedding(sid);

            Optional<String> departureFix = sidLegs.stream().filter(leg -> TransitionType.COMMON.equals(transitionEmbedding.get(leg.leg()).transitionType()))
                .findFirst().map(ResolvedLeg::leg).flatMap(Leg::associatedFix).map(Fix::fixIdentifier);

            return new ProcedureSummary.Builder()
                .procedureName(sid.procedureIdentifier())
                .entryExitFix(sidLegs.get(sidLegs.size() - 1).leg().associatedFix().map(Fix::fixIdentifier).orElse(null))
                .arrivalDepartureFix(departureFix.orElse(null))
                .equipage(sid.requiredNavigationEquipage())
                .build();
          });
    }

    private Map<Leg, Transition> transitionEmbedding(Procedure sid) {
      return TransitionSorter.INSTANCE.sortSidTransitions(sid.transitions()).stream()
          .flatMap(Collection::stream)
          .flatMap(transition -> transition.legs().stream().map(leg -> Pair.of(leg, transition)))
          .collect(elidingCollector(Pair::first, Pair::second));
    }
  }

  /**
   * Collector which (in the case of key conflicts) elides subsequent encounters of a given key.
   */
  private static <T, K, U> Collector<T, ?, LinkedHashMap<K, U>> elidingCollector(
      Function<? super T, ? extends K> keyMapper,
      Function<? super T, ? extends U> valueMapper) {
    return Collectors.toMap(keyMapper, valueMapper, (a, b) -> a, LinkedHashMap::new);
  }

  /**
   * Functional class for extracting common Approach features from an {@link ExpandedRoute}.
   */
  private static final class ApproachFeatureResolver implements Function<List<ResolvedLeg>, Optional<ProcedureSummary>> {

    private static final ApproachFeatureResolver INSTANCE = new ApproachFeatureResolver();

    @Override
    public Optional<ProcedureSummary> apply(List<ResolvedLeg> resolvedLegs) {
      return legsFromElement(resolvedLegs, ApproachElement.class).stream().reduce((l1, l2) -> l2)
          .map(approachLegs -> {
            Procedure approach = ((ApproachElement) approachLegs.get(0).sourceElement()).procedure();

            return new ProcedureSummary.Builder()
                .procedureName(approach.procedureIdentifier())
                .entryExitFix(approachLegs.get(0).leg().associatedFix().map(Fix::fixIdentifier).orElse(null))
                .equipage(approach.requiredNavigationEquipage())
                .build();
          });
    }
  }

  private static List<List<ResolvedLeg>> legsFromElement(List<ResolvedLeg> resolvedLegs, Class<? extends ResolvedElement> elementClass) {
    Predicate<ResolvedLeg> isFromElement = resolvedLeg -> elementClass.isAssignableFrom(resolvedLeg.sourceElement().getClass());
    return resolvedLegs.stream().collect(Partitioners.newListCollector(isFromElement)).stream()
        .filter(list -> isFromElement.test(list.get(0))).collect(Collectors.toList());
  }

  /**
   * Container class for summarized procedure information.
   */
  private static final class ProcedureSummary {

    private final String procedureName;
    private final String entryExitFix;
    private final String arrivalDepartureFix;
    private final RequiredNavigationEquipage equipage;

    private ProcedureSummary(Builder builder) {
      this.procedureName = builder.procedureName;
      this.entryExitFix = builder.entryExitFix;
      this.arrivalDepartureFix = builder.arrivalDepartureFix;
      this.equipage = builder.equipage;
    }

    public String procedureName() {
      return procedureName;
    }

    public String entryExitFix() {
      return entryExitFix;
    }

    public String arrivalDepartureFix() {
      return arrivalDepartureFix;
    }

    public RequiredNavigationEquipage equipage() {
      return equipage;
    }

    public Builder toBuilder() {
      return new Builder()
          .procedureName(procedureName())
          .entryExitFix(entryExitFix())
          .arrivalDepartureFix(arrivalDepartureFix())
          .equipage(equipage());
    }

    public static final class Builder {
      private String procedureName;
      private String entryExitFix;
      private String arrivalDepartureFix;
      private RequiredNavigationEquipage equipage;

      public Builder procedureName(String procedureName) {
        this.procedureName = procedureName;
        return this;
      }

      public Builder entryExitFix(String entryExitFix) {
        this.entryExitFix = entryExitFix;
        return this;
      }

      public Builder arrivalDepartureFix(String arrivalDepartureFix) {
        this.arrivalDepartureFix = arrivalDepartureFix;
        return this;
      }

      public Builder equipage(RequiredNavigationEquipage equipage) {
        this.equipage = equipage;
        return this;
      }

      public ProcedureSummary build() {
        return new ProcedureSummary(this);
      }
    }
  }
}