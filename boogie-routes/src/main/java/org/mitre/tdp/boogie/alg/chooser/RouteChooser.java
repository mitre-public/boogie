package org.mitre.tdp.boogie.alg.chooser;

import java.util.List;

import org.mitre.tdp.boogie.alg.ExpandedRoute;
import org.mitre.tdp.boogie.alg.chooser.graph.LinkingStrategy;
import org.mitre.tdp.boogie.alg.chooser.graph.TokenGrapher;
import org.mitre.tdp.boogie.alg.resolve.ResolvedLeg;
import org.mitre.tdp.boogie.alg.resolve.ResolvedToken;
import org.mitre.tdp.boogie.alg.resolve.ResolvedTokens;
import org.mitre.tdp.boogie.alg.resolve.RouteTokenResolver;
import org.mitre.tdp.boogie.alg.split.RouteToken;

import static java.util.Objects.requireNonNull;

/**
 * A {@link RouteChooser} is responsible for examining the {@link ResolvedTokens}s generated by {@link RouteTokenResolver}(s) and
 * building the flyable path which most likely represents the intended route (handling any ambiguity).
 *
 * <p>The verb "chooser" is used here to indicate that this is an active process, introspecting the various {@link ResolvedToken}s
 * generated for each input {@link RouteToken} and:
 * <ol>
 *   <li><em>Choosing</em> the most likely sequence of those elements</li>
 *   <li><em>Choosing</em> how to covert that series of elements into a flyable path</li>
 * </ol>
 */
@FunctionalInterface
public interface RouteChooser {

  /**
   * Returns a new {@link RouteChooser} which will use a shortest-path graph-traversal algorithm to determine the most likely
   * sequence of elements traversed by the flight.
   *
   * @param tokenGrapher    a method of converting individual {@link ResolvedToken}s to a graphical representation, see
   *                        {@link TokenGrapher#standard()}
   * @param linkingStrategy strategy for linking between subsequent elements of the route, see
   *                        {@link LinkingStrategy#standard(TokenGrapher)}
   */
  static RouteChooser graphical(TokenGrapher tokenGrapher, LinkingStrategy linkingStrategy) {
    return new GraphBasedRouteChooser(tokenGrapher, linkingStrategy);
  }

  static RouteChooser collapsing(RouteChooser chooser){
    return new Collapsing(chooser);
  }

  /**
   * Create a new {@link ExpandedRoute} from the provided ordered sequence of {@link ResolvedTokens}s extracted from the route
   * string. Each section contains a list of candidate {@link ResolvedToken}s which must be chosen between.
   *
   * @param resolvedTokens the ordered sequence of resolved tokens from the route string
   * @return the sequence of resolved legs in the order they're intended to be flown
   */
  List<ResolvedLeg> chooseRoute(List<ResolvedTokens> resolvedTokens);

  final class Collapsing implements RouteChooser {

    private final RouteChooser chooser;

    private Collapsing(RouteChooser chooser) {
      this.chooser = requireNonNull(chooser);
    }

    @Override
    public List<ResolvedLeg> chooseRoute(List<ResolvedTokens> resolvedTokens) {
      return chooser.chooseRoute(resolvedTokens);
    }
  }
}
