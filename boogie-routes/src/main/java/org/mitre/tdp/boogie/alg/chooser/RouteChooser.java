package org.mitre.tdp.boogie.alg.chooser;

import java.util.List;

import org.mitre.tdp.boogie.alg.ExpandedRoute;
import org.mitre.tdp.boogie.alg.chooser.graph.LinkingStrategy;
import org.mitre.tdp.boogie.alg.resolve.ResolvedToken;
import org.mitre.tdp.boogie.alg.resolve.ResolvedTokens;
import org.mitre.tdp.boogie.alg.resolve.RouteTokenResolver;
import org.mitre.tdp.boogie.alg.split.RouteToken;

/**
 * A {@link RouteChooser} is responsible for examining the {@link ResolvedTokens}s generated by {@link RouteTokenResolver}(s) and
 * building the flyable path which most likely represents the intended route (handling any ambiguity).
 *
 * <p>The verb "chooser" is used here to indicate that this is an active process, introspecting the various {@link ResolvedToken}s
 * generated for each input {@link RouteToken} and:
 * <ol>
 *   <li><em>Choosing</em> the most likely sequence of those elements</li>
 *   <li><em>Choosing</em> how to covert that series of elements into a flyable path</li>
 * </ol>
 */
@FunctionalInterface
public interface RouteChooser {

  /**
   * Returns a new {@link RouteChooser} which will use a shortest-path graph-traversal algorithm to determine the most likely
   * sequence of elements traversed by the flight.
   *
   * @param linkingStrategy the strategy to use for (1) converting elements to a graphical representation (2) for linking between
   *                        elements in the overall route graph. Typically {@link LinkingStrategy#standard()} works fine.
   */
  static RouteChooser graphical(LinkingStrategy linkingStrategy) {
    return new GraphBasedRouteChooser(linkingStrategy);
  }

  /**
   * Create a new {@link ExpandedRoute} from the provided ordered sequence of {@link ResolvedTokens}s extracted from the route
   * string. Each section contains a list of candidate {@link ResolvedToken}s which must be chosen between.
   *
   * @param resolvedTokens the sections of the route string (in the order they were filed)
   */
  ExpandedRoute chooseRoute(List<ResolvedTokens> resolvedTokens);
}
