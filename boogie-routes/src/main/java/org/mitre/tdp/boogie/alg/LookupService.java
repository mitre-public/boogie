package org.mitre.tdp.boogie.alg;

import static java.util.Collections.emptyList;
import static java.util.Objects.requireNonNull;

import java.util.Collection;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;

/**
 * Returns the set of elements of type 'I' matching a provided string identifier (typically a name for a procedure, airport, etc.)
 * assumed to be the way the element would show up in a route string.
 *
 * <p>This is provided as an interface to allow for calls to this to be backed by a variety of data sources ranging from local KV
 * maps structures to a remote database backend (though if using a remote service you may want to cache lookups locally).
 */
@FunctionalInterface
public interface LookupService<I> extends Function<String, Collection<I>> {

  /**
   * Returns a new {@link LookupService} which returns an immutable empty collection on any query.
   *
   * <p>This is useful as a stub for the optional services which can be provided to expander implementations if the client cannot
   * provide a backing query mechanism for those lookups.
   */
  static <I> LookupService<I> noop() {
    return s -> emptyList();
  }

  /**
   * Returns a new {@link LookupService} indexing the provided collection of records with the given set of indices generated by
   * the provided function.
   *
   * @param records the input data to index
   * @param indexer function generating one-or-more identifiers for a function
   */
  static <T> LookupService<T> inMemory(Iterable<T> records, Function<T, Stream<String>> indexer) {
    requireNonNull(indexer);

    ImmutableMultimap.Builder<String, T> lookup = ImmutableMultimap.builder();
    records.forEach(record -> indexer.apply(record).forEach(index -> lookup.put(index, record)));

    return new InMemory<>(lookup.build());
  }

  default LookupService<I> thenFilterWith(Predicate<I> predicate) {
    return s -> this.apply(s).stream().filter(predicate).collect(Collectors.toList());
  }

  default LookupService<I> thenApply(Function<Collection<I>, Collection<I>> function) {
    return s -> function.apply(this.apply(s));
  }

  final class InMemory<T> implements LookupService<T> {

    private final Multimap<String, T> lookup;

    private InMemory(Multimap<String, T> lookup) {
      this.lookup = lookup;
    }

    @Override
    public Collection<T> apply(String s) {
      return lookup.get(s);
    }
  }
}
