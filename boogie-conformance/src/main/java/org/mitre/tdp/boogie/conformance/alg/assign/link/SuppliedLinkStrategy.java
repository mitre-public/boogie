package org.mitre.tdp.boogie.conformance.alg.assign.link;

import java.util.List;

import org.mitre.caasd.commons.Pair;
import org.mitre.tdp.boogie.Airway;
import org.mitre.tdp.boogie.conformance.alg.assign.FlyableLeg;
import org.mitre.tdp.boogie.conformance.alg.assign.FlyableLegAssembler;
import org.mitre.tdp.boogie.conformance.alg.assign.Route;
import org.mitre.tdp.boogie.model.ProcedureGraph;

/**
 * This class supplies links between routes according to logic in the concrete implementations. While not terribly efficient to
 * create new flyable legs, it makes sure only the links we want get generated by linking routes explicitly.
 * <p>
 * This will be useful when you actually have all the candidate routes: In the case where it was sid->airway-star->approach
 * we would see many {@link ProcedureGraph#allPaths()} -> {@link Route<Airway>} -> many {@link ProcedureGraph#allPaths()} -> many {@link ProcedureGraph#allPaths()}
 */
public interface SuppliedLinkStrategy {
  static SuppliedLinkStrategy leftToRight() {
    return new LeftToRightLinker();
  }
  List<Pair<FlyableLeg, FlyableLeg>> generateLinks(Route<?> left, Route<?> right);

  final class LeftToRightLinker implements SuppliedLinkStrategy {
    private LeftToRightLinker() {}
    @Override
    public List<Pair<FlyableLeg, FlyableLeg>> generateLinks(Route<?> left, Route<?> right) {
      List<FlyableLeg> leftLegs = FlyableLegAssembler.assemble(left);
      List<FlyableLeg> rightLegs = FlyableLegAssembler.assemble(right);
      FlyableLeg a = leftLegs.get(leftLegs.size() -1);
      FlyableLeg b = rightLegs.get(0);
      return List.of(Pair.of(a, b));
    }
  }
}
